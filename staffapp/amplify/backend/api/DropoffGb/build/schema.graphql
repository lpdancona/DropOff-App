type AddressList @aws_iam @aws_api_key {
  id: ID!
  order: Int
  latitude: Float
  longitude: Float
  routeID: ID!
  Kid: Kid
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  addressListKidId: ID
}

enum RouteStatus {
  IN_PROGRESS
  FINISHED
  WAITING_TO_START
}

type Van @aws_iam @aws_api_key {
  id: ID!
  name: String
  image: String
  plate: String
  model: String
  year: String
  seats: String
  bosterSeats: String
  Kids(filter: ModelKidFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelKidConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Route @aws_iam @aws_api_key {
  id: ID
  date: String
  departTime: String
  lat: Float
  lng: Float
  driver: String
  helper: String
  route: AWSJSON
  Van: Van
  status: RouteStatus
  Kids(filter: ModelKidFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelKidConnection
  AddressLists(filter: ModelAddressListFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelAddressListConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  routeVanId: ID
}

type Kid @aws_iam @aws_api_key {
  id: ID!
  name: String!
  parent1Email: String
  parent2Email: String
  dropOffAddress: String
  lat: Float
  lng: Float
  birthDate: AWSDate
  photo: String
  vans: ID
  routeID: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum UserTypes {
  PARENT
  STAFF
  DRIVER
}

type User @aws_iam @aws_api_key {
  id: ID!
  sub: String!
  name: String!
  email: String
  unitNumber: String
  address: String!
  lng: Float!
  lat: Float!
  phoneNumber: String
  userType: UserTypes
  photo: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelAddressListConnection @aws_api_key @aws_iam {
  items: [AddressList]!
  nextToken: String
}

input ModelAddressListFilterInput {
  id: ModelIDInput
  order: ModelIntInput
  latitude: ModelFloatInput
  longitude: ModelFloatInput
  routeID: ModelIDInput
  and: [ModelAddressListFilterInput]
  or: [ModelAddressListFilterInput]
  not: ModelAddressListFilterInput
  addressListKidId: ModelIDInput
}

type Query {
  getAddressList(id: ID!): AddressList @aws_api_key @aws_iam
  listAddressLists(filter: ModelAddressListFilterInput, limit: Int, nextToken: String): ModelAddressListConnection @aws_api_key @aws_iam
  addressListsByRouteID(routeID: ID!, sortDirection: ModelSortDirection, filter: ModelAddressListFilterInput, limit: Int, nextToken: String): ModelAddressListConnection @aws_api_key @aws_iam
  getVan(id: ID!): Van @aws_api_key @aws_iam
  listVans(filter: ModelVanFilterInput, limit: Int, nextToken: String): ModelVanConnection @aws_api_key @aws_iam
  getRoute(id: ID!): Route @aws_api_key @aws_iam
  listRoutes(filter: ModelRouteFilterInput, limit: Int, nextToken: String): ModelRouteConnection @aws_api_key @aws_iam
  getKid(id: ID!): Kid @aws_api_key @aws_iam
  listKids(filter: ModelKidFilterInput, limit: Int, nextToken: String): ModelKidConnection @aws_api_key @aws_iam
  kidsByVans(vans: ID!, sortDirection: ModelSortDirection, filter: ModelKidFilterInput, limit: Int, nextToken: String): ModelKidConnection @aws_api_key @aws_iam
  kidsByRouteID(routeID: ID!, sortDirection: ModelSortDirection, filter: ModelKidFilterInput, limit: Int, nextToken: String): ModelKidConnection @aws_api_key @aws_iam
  getUser(id: ID!): User @aws_api_key @aws_iam
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection @aws_api_key @aws_iam
}

input ModelAddressListConditionInput {
  order: ModelIntInput
  latitude: ModelFloatInput
  longitude: ModelFloatInput
  routeID: ModelIDInput
  and: [ModelAddressListConditionInput]
  or: [ModelAddressListConditionInput]
  not: ModelAddressListConditionInput
  addressListKidId: ModelIDInput
}

input CreateAddressListInput {
  id: ID
  order: Int
  latitude: Float
  longitude: Float
  routeID: ID!
  addressListKidId: ID
}

input UpdateAddressListInput {
  id: ID!
  order: Int
  latitude: Float
  longitude: Float
  routeID: ID
  addressListKidId: ID
}

input DeleteAddressListInput {
  id: ID!
}

type Mutation {
  createAddressList(input: CreateAddressListInput!, condition: ModelAddressListConditionInput): AddressList @aws_api_key @aws_iam
  updateAddressList(input: UpdateAddressListInput!, condition: ModelAddressListConditionInput): AddressList @aws_api_key @aws_iam
  deleteAddressList(input: DeleteAddressListInput!, condition: ModelAddressListConditionInput): AddressList @aws_api_key @aws_iam
  createVan(input: CreateVanInput!, condition: ModelVanConditionInput): Van @aws_api_key @aws_iam
  updateVan(input: UpdateVanInput!, condition: ModelVanConditionInput): Van @aws_api_key @aws_iam
  deleteVan(input: DeleteVanInput!, condition: ModelVanConditionInput): Van @aws_api_key @aws_iam
  createRoute(input: CreateRouteInput!, condition: ModelRouteConditionInput): Route @aws_api_key @aws_iam
  updateRoute(input: UpdateRouteInput!, condition: ModelRouteConditionInput): Route @aws_api_key @aws_iam
  deleteRoute(input: DeleteRouteInput!, condition: ModelRouteConditionInput): Route @aws_api_key @aws_iam
  createKid(input: CreateKidInput!, condition: ModelKidConditionInput): Kid @aws_api_key @aws_iam
  updateKid(input: UpdateKidInput!, condition: ModelKidConditionInput): Kid @aws_api_key @aws_iam
  deleteKid(input: DeleteKidInput!, condition: ModelKidConditionInput): Kid @aws_api_key @aws_iam
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
}

input ModelSubscriptionAddressListFilterInput {
  id: ModelSubscriptionIDInput
  order: ModelSubscriptionIntInput
  latitude: ModelSubscriptionFloatInput
  longitude: ModelSubscriptionFloatInput
  routeID: ModelSubscriptionIDInput
  and: [ModelSubscriptionAddressListFilterInput]
  or: [ModelSubscriptionAddressListFilterInput]
}

type Subscription {
  onCreateAddressList(filter: ModelSubscriptionAddressListFilterInput): AddressList @aws_subscribe(mutations: ["createAddressList"]) @aws_api_key @aws_iam
  onUpdateAddressList(filter: ModelSubscriptionAddressListFilterInput): AddressList @aws_subscribe(mutations: ["updateAddressList"]) @aws_api_key @aws_iam
  onDeleteAddressList(filter: ModelSubscriptionAddressListFilterInput): AddressList @aws_subscribe(mutations: ["deleteAddressList"]) @aws_api_key @aws_iam
  onCreateVan(filter: ModelSubscriptionVanFilterInput): Van @aws_subscribe(mutations: ["createVan"]) @aws_api_key @aws_iam
  onUpdateVan(filter: ModelSubscriptionVanFilterInput): Van @aws_subscribe(mutations: ["updateVan"]) @aws_api_key @aws_iam
  onDeleteVan(filter: ModelSubscriptionVanFilterInput): Van @aws_subscribe(mutations: ["deleteVan"]) @aws_api_key @aws_iam
  onCreateRoute(filter: ModelSubscriptionRouteFilterInput): Route @aws_subscribe(mutations: ["createRoute"]) @aws_api_key @aws_iam
  onUpdateRoute(filter: ModelSubscriptionRouteFilterInput): Route @aws_subscribe(mutations: ["updateRoute"]) @aws_api_key @aws_iam
  onDeleteRoute(filter: ModelSubscriptionRouteFilterInput): Route @aws_subscribe(mutations: ["deleteRoute"]) @aws_api_key @aws_iam
  onCreateKid(filter: ModelSubscriptionKidFilterInput): Kid @aws_subscribe(mutations: ["createKid"]) @aws_api_key @aws_iam
  onUpdateKid(filter: ModelSubscriptionKidFilterInput): Kid @aws_subscribe(mutations: ["updateKid"]) @aws_api_key @aws_iam
  onDeleteKid(filter: ModelSubscriptionKidFilterInput): Kid @aws_subscribe(mutations: ["deleteKid"]) @aws_api_key @aws_iam
  onCreateUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: ["createUser"]) @aws_api_key @aws_iam
  onUpdateUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: ["updateUser"]) @aws_api_key @aws_iam
  onDeleteUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: ["deleteUser"]) @aws_api_key @aws_iam
}

type ModelVanConnection @aws_api_key @aws_iam {
  items: [Van]!
  nextToken: String
}

input ModelVanFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  image: ModelStringInput
  plate: ModelStringInput
  model: ModelStringInput
  year: ModelStringInput
  seats: ModelStringInput
  bosterSeats: ModelStringInput
  and: [ModelVanFilterInput]
  or: [ModelVanFilterInput]
  not: ModelVanFilterInput
}

input ModelVanConditionInput {
  name: ModelStringInput
  image: ModelStringInput
  plate: ModelStringInput
  model: ModelStringInput
  year: ModelStringInput
  seats: ModelStringInput
  bosterSeats: ModelStringInput
  and: [ModelVanConditionInput]
  or: [ModelVanConditionInput]
  not: ModelVanConditionInput
}

input CreateVanInput {
  id: ID
  name: String
  image: String
  plate: String
  model: String
  year: String
  seats: String
  bosterSeats: String
}

input UpdateVanInput {
  id: ID!
  name: String
  image: String
  plate: String
  model: String
  year: String
  seats: String
  bosterSeats: String
}

input DeleteVanInput {
  id: ID!
}

input ModelSubscriptionVanFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  image: ModelSubscriptionStringInput
  plate: ModelSubscriptionStringInput
  model: ModelSubscriptionStringInput
  year: ModelSubscriptionStringInput
  seats: ModelSubscriptionStringInput
  bosterSeats: ModelSubscriptionStringInput
  and: [ModelSubscriptionVanFilterInput]
  or: [ModelSubscriptionVanFilterInput]
}

type ModelRouteConnection @aws_api_key @aws_iam {
  items: [Route]!
  nextToken: String
}

input ModelRouteStatusInput {
  eq: RouteStatus
  ne: RouteStatus
}

input ModelRouteFilterInput {
  id: ModelIDInput
  date: ModelStringInput
  departTime: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  driver: ModelStringInput
  helper: ModelStringInput
  route: ModelStringInput
  status: ModelRouteStatusInput
  and: [ModelRouteFilterInput]
  or: [ModelRouteFilterInput]
  not: ModelRouteFilterInput
  routeVanId: ModelIDInput
}

input ModelRouteConditionInput {
  date: ModelStringInput
  departTime: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  driver: ModelStringInput
  helper: ModelStringInput
  route: ModelStringInput
  status: ModelRouteStatusInput
  and: [ModelRouteConditionInput]
  or: [ModelRouteConditionInput]
  not: ModelRouteConditionInput
  routeVanId: ModelIDInput
}

input CreateRouteInput {
  id: ID
  date: String
  departTime: String
  lat: Float
  lng: Float
  driver: String
  helper: String
  route: AWSJSON
  status: RouteStatus
  routeVanId: ID
}

input UpdateRouteInput {
  id: ID!
  date: String
  departTime: String
  lat: Float
  lng: Float
  driver: String
  helper: String
  route: AWSJSON
  status: RouteStatus
  routeVanId: ID
}

input DeleteRouteInput {
  id: ID!
}

input ModelSubscriptionRouteFilterInput {
  id: ModelSubscriptionIDInput
  date: ModelSubscriptionStringInput
  departTime: ModelSubscriptionStringInput
  lat: ModelSubscriptionFloatInput
  lng: ModelSubscriptionFloatInput
  driver: ModelSubscriptionStringInput
  helper: ModelSubscriptionStringInput
  route: ModelSubscriptionStringInput
  status: ModelSubscriptionStringInput
  and: [ModelSubscriptionRouteFilterInput]
  or: [ModelSubscriptionRouteFilterInput]
}

type ModelKidConnection @aws_iam @aws_api_key {
  items: [Kid]!
  nextToken: String
}

input ModelKidFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  parent1Email: ModelStringInput
  parent2Email: ModelStringInput
  dropOffAddress: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  birthDate: ModelStringInput
  photo: ModelStringInput
  vans: ModelIDInput
  routeID: ModelIDInput
  and: [ModelKidFilterInput]
  or: [ModelKidFilterInput]
  not: ModelKidFilterInput
}

input ModelKidConditionInput {
  name: ModelStringInput
  parent1Email: ModelStringInput
  parent2Email: ModelStringInput
  dropOffAddress: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  birthDate: ModelStringInput
  photo: ModelStringInput
  vans: ModelIDInput
  routeID: ModelIDInput
  and: [ModelKidConditionInput]
  or: [ModelKidConditionInput]
  not: ModelKidConditionInput
}

input CreateKidInput {
  id: ID
  name: String!
  parent1Email: String
  parent2Email: String
  dropOffAddress: String
  lat: Float
  lng: Float
  birthDate: AWSDate
  photo: String
  vans: ID
  routeID: ID
}

input UpdateKidInput {
  id: ID!
  name: String
  parent1Email: String
  parent2Email: String
  dropOffAddress: String
  lat: Float
  lng: Float
  birthDate: AWSDate
  photo: String
  vans: ID
  routeID: ID
}

input DeleteKidInput {
  id: ID!
}

input ModelSubscriptionKidFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  parent1Email: ModelSubscriptionStringInput
  parent2Email: ModelSubscriptionStringInput
  dropOffAddress: ModelSubscriptionStringInput
  lat: ModelSubscriptionFloatInput
  lng: ModelSubscriptionFloatInput
  birthDate: ModelSubscriptionStringInput
  photo: ModelSubscriptionStringInput
  vans: ModelSubscriptionIDInput
  routeID: ModelSubscriptionIDInput
  and: [ModelSubscriptionKidFilterInput]
  or: [ModelSubscriptionKidFilterInput]
}

type ModelUserConnection @aws_api_key @aws_iam {
  items: [User]!
  nextToken: String
}

input ModelUserTypesInput {
  eq: UserTypes
  ne: UserTypes
}

input ModelUserFilterInput {
  id: ModelIDInput
  sub: ModelStringInput
  name: ModelStringInput
  email: ModelStringInput
  unitNumber: ModelStringInput
  address: ModelStringInput
  lng: ModelFloatInput
  lat: ModelFloatInput
  phoneNumber: ModelStringInput
  userType: ModelUserTypesInput
  photo: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

input ModelUserConditionInput {
  sub: ModelStringInput
  name: ModelStringInput
  email: ModelStringInput
  unitNumber: ModelStringInput
  address: ModelStringInput
  lng: ModelFloatInput
  lat: ModelFloatInput
  phoneNumber: ModelStringInput
  userType: ModelUserTypesInput
  photo: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
}

input CreateUserInput {
  id: ID
  sub: String!
  name: String!
  email: String
  unitNumber: String
  address: String!
  lng: Float!
  lat: Float!
  phoneNumber: String
  userType: UserTypes
  photo: String
}

input UpdateUserInput {
  id: ID!
  sub: String
  name: String
  email: String
  unitNumber: String
  address: String
  lng: Float
  lat: Float
  phoneNumber: String
  userType: UserTypes
  photo: String
}

input DeleteUserInput {
  id: ID!
}

input ModelSubscriptionUserFilterInput {
  id: ModelSubscriptionIDInput
  sub: ModelSubscriptionStringInput
  name: ModelSubscriptionStringInput
  email: ModelSubscriptionStringInput
  unitNumber: ModelSubscriptionStringInput
  address: ModelSubscriptionStringInput
  lng: ModelSubscriptionFloatInput
  lat: ModelSubscriptionFloatInput
  phoneNumber: ModelSubscriptionStringInput
  userType: ModelSubscriptionStringInput
  photo: ModelSubscriptionStringInput
  and: [ModelSubscriptionUserFilterInput]
  or: [ModelSubscriptionUserFilterInput]
}
