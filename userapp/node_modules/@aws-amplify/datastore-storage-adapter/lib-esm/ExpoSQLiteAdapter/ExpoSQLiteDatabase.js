import { __awaiter, __generator, __read, __spread } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { ConsoleLogger as Logger } from '@aws-amplify/core';
import { deleteAsync, documentDirectory } from 'expo-file-system';
import { openDatabase } from 'expo-sqlite';
import { DB_NAME } from '../common/constants';
var logger = new Logger('ExpoSQLiteDatabase');
/*

Note:
ExpoSQLite transaction error callbacks require returning a boolean value to indicate whether the
error was handled or not. Returning a true value indicates the error was handled and does not
rollback the whole transaction.

*/
var ExpoSQLiteDatabase = /** @class */ (function () {
    function ExpoSQLiteDatabase() {
    }
    ExpoSQLiteDatabase.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // only open database once.
                if (!this.db) {
                    // As per expo docs version, description and size arguments are ignored,
                    // but are accepted by the function for compatibility with the WebSQL specification.
                    // Hence, we do not need those arguments.
                    this.db = openDatabase(DB_NAME);
                }
                return [2 /*return*/];
            });
        });
    };
    ExpoSQLiteDatabase.prototype.createSchema = function (statements) {
        return this.executeStatements(statements);
    };
    ExpoSQLiteDatabase.prototype.clear = function () {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        logger.debug('Clearing database');
                        return [4 /*yield*/, this.closeDB()];
                    case 1:
                        _a.sent();
                        // delete database is not supported by expo-sqlite.
                        // Database file needs to be deleted using deleteAsync from expo-file-system
                        return [4 /*yield*/, deleteAsync(documentDirectory + "SQLite/" + DB_NAME)];
                    case 2:
                        // delete database is not supported by expo-sqlite.
                        // Database file needs to be deleted using deleteAsync from expo-file-system
                        _a.sent();
                        logger.debug('Database cleared');
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        logger.warn('Error clearing the database.', error_1);
                        // open database if it was closed earlier and this.db was set to undefined.
                        this.init();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    ExpoSQLiteDatabase.prototype.get = function (statement, params) {
        return __awaiter(this, void 0, void 0, function () {
            var results;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getAll(statement, params)];
                    case 1:
                        results = _a.sent();
                        return [2 /*return*/, results[0]];
                }
            });
        });
    };
    ExpoSQLiteDatabase.prototype.getAll = function (statement, params) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.db.readTransaction(function (transaction) {
                transaction.executeSql(statement, params, function (_, result) {
                    resolve(result.rows._array || []);
                }, function (_, error) {
                    reject(error);
                    logger.warn(error);
                    return true;
                });
            });
        });
    };
    ExpoSQLiteDatabase.prototype.save = function (statement, params) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.db.transaction(function (transaction) {
                transaction.executeSql(statement, params, function () {
                    resolve(null);
                }, function (_, error) {
                    reject(error);
                    logger.warn(error);
                    return true;
                });
            });
        });
    };
    ExpoSQLiteDatabase.prototype.batchQuery = function (queryParameterizedStatements) {
        var _this = this;
        if (queryParameterizedStatements === void 0) { queryParameterizedStatements = new Set(); }
        return new Promise(function (resolveTransaction, rejectTransaction) {
            _this.db.transaction(function (transaction) { return __awaiter(_this, void 0, void 0, function () {
                var results, error_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, Promise.all(__spread(queryParameterizedStatements).map(function (_a) {
                                    var _b = __read(_a, 2), statement = _b[0], params = _b[1];
                                    return new Promise(function (resolve, reject) {
                                        transaction.executeSql(statement, params, function (_, result) {
                                            resolve(result.rows._array[0]);
                                        }, function (_, error) {
                                            reject(error);
                                            logger.warn(error);
                                            return true;
                                        });
                                    });
                                }))];
                        case 1:
                            results = _a.sent();
                            resolveTransaction(results);
                            return [3 /*break*/, 3];
                        case 2:
                            error_2 = _a.sent();
                            rejectTransaction(error_2);
                            logger.warn(error_2);
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            }); });
        });
    };
    ExpoSQLiteDatabase.prototype.batchSave = function (saveParameterizedStatements, deleteParameterizedStatements) {
        var _this = this;
        if (saveParameterizedStatements === void 0) { saveParameterizedStatements = new Set(); }
        return new Promise(function (resolveTransaction, rejectTransaction) {
            _this.db.transaction(function (transaction) { return __awaiter(_this, void 0, void 0, function () {
                var error_3;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 4, , 5]);
                            // await for all sql statements promises to resolve
                            return [4 /*yield*/, Promise.all(__spread(saveParameterizedStatements).map(function (_a) {
                                    var _b = __read(_a, 2), statement = _b[0], params = _b[1];
                                    return new Promise(function (resolve, reject) {
                                        transaction.executeSql(statement, params, function () {
                                            resolve(null);
                                        }, function (_, error) {
                                            reject(error);
                                            logger.warn(error);
                                            return true;
                                        });
                                    });
                                }))];
                        case 1:
                            // await for all sql statements promises to resolve
                            _a.sent();
                            if (!deleteParameterizedStatements) return [3 /*break*/, 3];
                            return [4 /*yield*/, Promise.all(__spread(deleteParameterizedStatements).map(function (_a) {
                                    var _b = __read(_a, 2), statement = _b[0], params = _b[1];
                                    return new Promise(function (resolve, reject) {
                                        return transaction.executeSql(statement, params, function () {
                                            resolve(null);
                                        }, function (_, error) {
                                            reject(error);
                                            logger.warn(error);
                                            return true;
                                        });
                                    });
                                }))];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            resolveTransaction(null);
                            return [3 /*break*/, 5];
                        case 4:
                            error_3 = _a.sent();
                            rejectTransaction(error_3);
                            logger.warn(error_3);
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            }); });
        });
    };
    ExpoSQLiteDatabase.prototype.selectAndDelete = function (queryParameterizedStatement, deleteParameterizedStatement) {
        var _this = this;
        var _a = __read(queryParameterizedStatement, 2), queryStatement = _a[0], queryParams = _a[1];
        var _b = __read(deleteParameterizedStatement, 2), deleteStatement = _b[0], deleteParams = _b[1];
        return new Promise(function (resolveTransaction, rejectTransaction) {
            _this.db.transaction(function (transaction) { return __awaiter(_this, void 0, void 0, function () {
                var result, error_4;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 3, , 4]);
                            return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    transaction.executeSql(queryStatement, queryParams, function (_, result) {
                                        resolve(result.rows._array || []);
                                    }, function (_, error) {
                                        reject(error);
                                        logger.warn(error);
                                        return true;
                                    });
                                })];
                        case 1:
                            result = _a.sent();
                            return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    transaction.executeSql(deleteStatement, deleteParams, function () {
                                        resolve(null);
                                    }, function (_, error) {
                                        reject(error);
                                        logger.warn(error);
                                        return true;
                                    });
                                })];
                        case 2:
                            _a.sent();
                            resolveTransaction(result);
                            return [3 /*break*/, 4];
                        case 3:
                            error_4 = _a.sent();
                            rejectTransaction(error_4);
                            logger.warn(error_4);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
        });
    };
    ExpoSQLiteDatabase.prototype.executeStatements = function (statements) {
        var _this = this;
        return new Promise(function (resolveTransaction, rejectTransaction) {
            _this.db.transaction(function (transaction) { return __awaiter(_this, void 0, void 0, function () {
                var error_5;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, Promise.all(statements.map(function (statement) {
                                    return new Promise(function (resolve, reject) {
                                        transaction.executeSql(statement, [], function () {
                                            resolve(null);
                                        }, function (_, error) {
                                            reject(error);
                                            return true;
                                        });
                                    });
                                }))];
                        case 1:
                            _a.sent();
                            resolveTransaction(null);
                            return [3 /*break*/, 3];
                        case 2:
                            error_5 = _a.sent();
                            rejectTransaction(error_5);
                            logger.warn(error_5);
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            }); });
        });
    };
    ExpoSQLiteDatabase.prototype.closeDB = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.db) return [3 /*break*/, 2];
                        logger.debug('Closing Database');
                        // closing database is not supported by expo-sqlite.
                        // Workaround is to access the private db variable and call the close() method.
                        return [4 /*yield*/, this.db._db.close()];
                    case 1:
                        // closing database is not supported by expo-sqlite.
                        // Workaround is to access the private db variable and call the close() method.
                        _a.sent();
                        logger.debug('Database closed');
                        this.db = undefined;
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    return ExpoSQLiteDatabase;
}());
export default ExpoSQLiteDatabase;
//# sourceMappingURL=ExpoSQLiteDatabase.js.map