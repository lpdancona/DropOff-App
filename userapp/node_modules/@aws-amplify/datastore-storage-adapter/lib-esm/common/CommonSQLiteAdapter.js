import { __asyncValues, __awaiter, __generator, __read, __values } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { ConsoleLogger as Logger } from '@aws-amplify/core';
import { generateSchemaStatements, queryByIdStatement, modelUpdateStatement, modelInsertStatement, queryAllStatement, queryOneStatement, deleteByIdStatement, deleteByPredicateStatement, } from '../common/SQLiteUtils';
import { ModelPredicateCreator, ModelSortPredicateCreator, isPredicateObj, OpType, QueryOne, utils, } from '@aws-amplify/datastore';
var traverseModel = utils.traverseModel, validatePredicate = utils.validatePredicate, isModelConstructor = utils.isModelConstructor;
var logger = new Logger('DataStore');
var CommonSQLiteAdapter = /** @class */ (function () {
    function CommonSQLiteAdapter(db) {
        this.db = db;
    }
    CommonSQLiteAdapter.prototype.setUp = function (theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName) {
        return __awaiter(this, void 0, void 0, function () {
            var usesCPKCodegen, statements, error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.initPromise) return [3 /*break*/, 1];
                        this.initPromise = new Promise(function (res, rej) {
                            _this.resolve = res;
                            _this.reject = rej;
                        });
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.initPromise];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                    case 3:
                        this.schema = theSchema;
                        this.namespaceResolver = namespaceResolver;
                        this.modelInstanceCreator = modelInstanceCreator;
                        this.getModelConstructorByModelName = getModelConstructorByModelName;
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, 7, , 8]);
                        usesCPKCodegen = Object.values(this.schema.namespaces.user.models).some(function (model) {
                            return Object.values(model.fields).some(function (field) { var _a; return (_a = field.association) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('targetNames'); });
                        });
                        if (usesCPKCodegen) {
                            logger.error('The SQLite adapter does not support schemas using custom primary key. Set `graphQLTransformer.respectPrimaryKeyAttributesOnConnectionField in `amplify/cli.json` to false to disable custom primary key. To regenerate your API, add or remove an empty newline to your GraphQL schema (to change the computed hash) then run `amplify push`.');
                        }
                        return [4 /*yield*/, this.db.init()];
                    case 5:
                        _a.sent();
                        statements = generateSchemaStatements(this.schema);
                        return [4 /*yield*/, this.db.createSchema(statements)];
                    case 6:
                        _a.sent();
                        this.resolve();
                        return [3 /*break*/, 8];
                    case 7:
                        error_1 = _a.sent();
                        this.reject(error_1);
                        return [3 /*break*/, 8];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    CommonSQLiteAdapter.prototype.clear = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.db.clear()];
                    case 1:
                        _a.sent();
                        this.initPromise = undefined;
                        return [2 /*return*/];
                }
            });
        });
    };
    CommonSQLiteAdapter.prototype.save = function (model, condition) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function () {
            var modelConstructor, tableName, connectedModels, connectionStoreNames, _b, queryStatement, params, fromDB, predicates, predicateObjs, type, isValid, msg, result, saveStatements, connectionStoreNames_1, connectionStoreNames_1_1, resItem, modelName, item, instance, id, _c, queryStatement_1, params_1, fromDB_1, opType, saveStatement, e_1_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        modelConstructor = Object.getPrototypeOf(model)
                            .constructor;
                        tableName = modelConstructor.name;
                        connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[this.namespaceResolver(modelConstructor)], this.modelInstanceCreator, this.getModelConstructorByModelName);
                        connectionStoreNames = Object.values(connectedModels).map(function (_a) {
                            var modelName = _a.modelName, item = _a.item, instance = _a.instance;
                            return { modelName: modelName, item: item, instance: instance };
                        });
                        _b = __read(queryByIdStatement(model.id, tableName), 2), queryStatement = _b[0], params = _b[1];
                        return [4 /*yield*/, this.db.get(queryStatement, params)];
                    case 1:
                        fromDB = _d.sent();
                        if (condition && fromDB) {
                            predicates = ModelPredicateCreator.getPredicates(condition);
                            predicateObjs = predicates.predicates, type = predicates.type;
                            isValid = validatePredicate(fromDB, type, predicateObjs);
                            if (!isValid) {
                                msg = 'Conditional update failed';
                                logger.error(msg, { model: fromDB, condition: predicateObjs });
                                throw new Error(msg);
                            }
                        }
                        result = [];
                        saveStatements = new Set();
                        _d.label = 2;
                    case 2:
                        _d.trys.push([2, 8, 9, 14]);
                        connectionStoreNames_1 = __asyncValues(connectionStoreNames);
                        _d.label = 3;
                    case 3: return [4 /*yield*/, connectionStoreNames_1.next()];
                    case 4:
                        if (!(connectionStoreNames_1_1 = _d.sent(), !connectionStoreNames_1_1.done)) return [3 /*break*/, 7];
                        resItem = connectionStoreNames_1_1.value;
                        modelName = resItem.modelName, item = resItem.item, instance = resItem.instance;
                        id = item.id;
                        _c = __read(queryByIdStatement(id, modelName), 2), queryStatement_1 = _c[0], params_1 = _c[1];
                        return [4 /*yield*/, this.db.get(queryStatement_1, params_1)];
                    case 5:
                        fromDB_1 = _d.sent();
                        opType = fromDB_1 === undefined ? OpType.INSERT : OpType.UPDATE;
                        saveStatement = fromDB_1
                            ? modelUpdateStatement(instance, modelName)
                            : modelInsertStatement(instance, modelName);
                        if (id === model.id || opType === OpType.INSERT) {
                            saveStatements.add(saveStatement);
                            result.push([instance, opType]);
                        }
                        _d.label = 6;
                    case 6: return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _d.trys.push([9, , 12, 13]);
                        if (!(connectionStoreNames_1_1 && !connectionStoreNames_1_1.done && (_a = connectionStoreNames_1.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, _a.call(connectionStoreNames_1)];
                    case 10:
                        _d.sent();
                        _d.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14: return [4 /*yield*/, this.db.batchSave(saveStatements)];
                    case 15:
                        _d.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    CommonSQLiteAdapter.prototype.load = function (namespaceName, srcModelName, records) {
        return __awaiter(this, void 0, void 0, function () {
            var namespace, relations, connectionTableNames, modelConstructor;
            var _this = this;
            return __generator(this, function (_a) {
                namespace = this.schema.namespaces[namespaceName];
                relations = namespace.relationships[srcModelName].relationTypes;
                connectionTableNames = relations.map(function (_a) {
                    var modelName = _a.modelName;
                    return modelName;
                });
                modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);
                if (connectionTableNames.length === 0) {
                    return [2 /*return*/, records.map(function (record) {
                            return _this.modelInstanceCreator(modelConstructor, record);
                        })];
                }
                // Remove related-model fields. They're all `null` in the database,
                // and any that happen to be required will result in a false validation
                // error when DataStore attempts to initialize with `null`.
                // These fields aren't actually needed here. DataStore will use the FK's
                // from the schema model.
                return [2 /*return*/, records.map(function (record) {
                        var e_2, _a;
                        try {
                            for (var relations_1 = __values(relations), relations_1_1 = relations_1.next(); !relations_1_1.done; relations_1_1 = relations_1.next()) {
                                var r = relations_1_1.value;
                                delete record[r.fieldName];
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (relations_1_1 && !relations_1_1.done && (_a = relations_1.return)) _a.call(relations_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        return _this.modelInstanceCreator(modelConstructor, record);
                    })];
            });
        });
    };
    CommonSQLiteAdapter.prototype.query = function (modelConstructor, predicate, pagination) {
        return __awaiter(this, void 0, void 0, function () {
            var tableName, namespaceName, predicates, sortPredicates, limit, page, queryById, records;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tableName = modelConstructor.name;
                        namespaceName = this.namespaceResolver(modelConstructor);
                        predicates = predicate && ModelPredicateCreator.getPredicates(predicate);
                        sortPredicates = pagination &&
                            pagination.sort &&
                            ModelSortPredicateCreator.getPredicates(pagination.sort);
                        limit = pagination && pagination.limit;
                        page = limit && pagination.page;
                        queryById = predicates && this.idFromPredicate(predicates);
                        return [4 /*yield*/, (function () { return __awaiter(_this, void 0, void 0, function () {
                                var record, _a, queryStatement, params;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            if (!queryById) return [3 /*break*/, 2];
                                            return [4 /*yield*/, this.getById(tableName, queryById)];
                                        case 1:
                                            record = _b.sent();
                                            return [2 /*return*/, record ? [record] : []];
                                        case 2:
                                            _a = __read(queryAllStatement(tableName, predicates, sortPredicates, limit, page), 2), queryStatement = _a[0], params = _a[1];
                                            return [4 /*yield*/, this.db.getAll(queryStatement, params)];
                                        case 3: return [2 /*return*/, _b.sent()];
                                    }
                                });
                            }); })()];
                    case 1:
                        records = _a.sent();
                        return [4 /*yield*/, this.load(namespaceName, modelConstructor.name, records)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    CommonSQLiteAdapter.prototype.getById = function (tableName, id) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, queryStatement, params, record;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = __read(queryByIdStatement(id, tableName), 2), queryStatement = _a[0], params = _a[1];
                        return [4 /*yield*/, this.db.get(queryStatement, params)];
                    case 1:
                        record = _b.sent();
                        return [2 /*return*/, record];
                }
            });
        });
    };
    CommonSQLiteAdapter.prototype.idFromPredicate = function (predicates) {
        var predicateObjs = predicates.predicates;
        var idPredicate = predicateObjs.length === 1 &&
            predicateObjs.find(function (p) { return isPredicateObj(p) && p.field === 'id' && p.operator === 'eq'; });
        return idPredicate && idPredicate.operand;
    };
    CommonSQLiteAdapter.prototype.queryOne = function (modelConstructor, firstOrLast) {
        if (firstOrLast === void 0) { firstOrLast = QueryOne.FIRST; }
        return __awaiter(this, void 0, void 0, function () {
            var tableName, _a, queryStatement, params, result, modelInstance;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tableName = modelConstructor.name;
                        _a = __read(queryOneStatement(firstOrLast, tableName), 2), queryStatement = _a[0], params = _a[1];
                        return [4 /*yield*/, this.db.get(queryStatement, params)];
                    case 1:
                        result = _b.sent();
                        modelInstance = result && this.modelInstanceCreator(modelConstructor, result);
                        return [2 /*return*/, modelInstance];
                }
            });
        });
    };
    // Currently does not cascade
    // TODO: use FKs in relations and have `ON DELETE CASCADE` set
    // For Has Many and Has One relations to have SQL handle cascades automatically
    CommonSQLiteAdapter.prototype.delete = function (modelOrModelConstructor, condition) {
        return __awaiter(this, void 0, void 0, function () {
            var modelConstructor, namespaceName, tableName, predicates, queryStatement, deleteStatement, models, modelInstances, model, modelConstructor, tableName, _a, queryStatement, params, fromDB, msg, predicates, predicateObjs, type, isValid, msg, _b, deleteStatement, deleteParams, _c, deleteStatement, params;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!isModelConstructor(modelOrModelConstructor)) return [3 /*break*/, 3];
                        modelConstructor = modelOrModelConstructor;
                        namespaceName = this.namespaceResolver(modelConstructor);
                        tableName = modelConstructor.name;
                        predicates = condition && ModelPredicateCreator.getPredicates(condition);
                        queryStatement = queryAllStatement(tableName, predicates);
                        deleteStatement = deleteByPredicateStatement(tableName, predicates);
                        return [4 /*yield*/, this.db.selectAndDelete(queryStatement, deleteStatement)];
                    case 1:
                        models = _d.sent();
                        return [4 /*yield*/, this.load(namespaceName, modelConstructor.name, models)];
                    case 2:
                        modelInstances = _d.sent();
                        return [2 /*return*/, [modelInstances, modelInstances]];
                    case 3:
                        model = modelOrModelConstructor;
                        modelConstructor = Object.getPrototypeOf(model)
                            .constructor;
                        tableName = modelConstructor.name;
                        if (!condition) return [3 /*break*/, 6];
                        _a = __read(queryByIdStatement(model.id, tableName), 2), queryStatement = _a[0], params = _a[1];
                        return [4 /*yield*/, this.db.get(queryStatement, params)];
                    case 4:
                        fromDB = _d.sent();
                        if (fromDB === undefined) {
                            msg = 'Model instance not found in storage';
                            logger.warn(msg, { model: model });
                            return [2 /*return*/, [[model], []]];
                        }
                        predicates = ModelPredicateCreator.getPredicates(condition);
                        predicateObjs = predicates.predicates, type = predicates.type;
                        isValid = validatePredicate(fromDB, type, predicateObjs);
                        if (!isValid) {
                            msg = 'Conditional update failed';
                            logger.error(msg, { model: fromDB, condition: predicateObjs });
                            throw new Error(msg);
                        }
                        _b = __read(deleteByIdStatement(model.id, tableName), 2), deleteStatement = _b[0], deleteParams = _b[1];
                        return [4 /*yield*/, this.db.save(deleteStatement, deleteParams)];
                    case 5:
                        _d.sent();
                        return [2 /*return*/, [[model], [model]]];
                    case 6:
                        _c = __read(deleteByIdStatement(model.id, tableName), 2), deleteStatement = _c[0], params = _c[1];
                        return [4 /*yield*/, this.db.save(deleteStatement, params)];
                    case 7:
                        _d.sent();
                        return [2 /*return*/, [[model], [model]]];
                }
            });
        });
    };
    CommonSQLiteAdapter.prototype.batchSave = function (modelConstructor, items) {
        return __awaiter(this, void 0, void 0, function () {
            var tableName, result, itemsToSave, queryStatements, deleteStatements, saveStatements, _loop_1, this_1, items_1, items_1_1, item, queryResponses;
            var e_3, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tableName = modelConstructor.name;
                        result = [];
                        itemsToSave = [];
                        queryStatements = new Set();
                        deleteStatements = new Set();
                        saveStatements = new Set();
                        _loop_1 = function (item) {
                            var connectedModels = traverseModel(modelConstructor.name, this_1.modelInstanceCreator(modelConstructor, item), this_1.schema.namespaces[this_1.namespaceResolver(modelConstructor)], this_1.modelInstanceCreator, this_1.getModelConstructorByModelName);
                            var id = item.id, _deleted = item._deleted;
                            var instance = connectedModels.find(function (_a) {
                                var instance = _a.instance;
                                return instance.id === id;
                            }).instance;
                            if (_deleted) {
                                // create the delete statements right away
                                var deleteStatement = deleteByIdStatement(instance.id, tableName);
                                deleteStatements.add(deleteStatement);
                                result.push([item, OpType.DELETE]);
                            }
                            else {
                                // query statements for the saves at first
                                var queryStatement = queryByIdStatement(id, tableName);
                                queryStatements.add(queryStatement);
                                // combination of insert and update items
                                itemsToSave.push(instance);
                            }
                        };
                        this_1 = this;
                        try {
                            for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                                item = items_1_1.value;
                                _loop_1(item);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                        return [4 /*yield*/, this.db.batchQuery(queryStatements)];
                    case 1:
                        queryResponses = _b.sent();
                        queryResponses.forEach(function (response, idx) {
                            if (response === undefined) {
                                var insertStatement = modelInsertStatement(itemsToSave[idx], tableName);
                                saveStatements.add(insertStatement);
                                result.push([itemsToSave[idx], OpType.INSERT]);
                            }
                            else {
                                var updateStatement = modelUpdateStatement(itemsToSave[idx], tableName);
                                saveStatements.add(updateStatement);
                                result.push([itemsToSave[idx], OpType.UPDATE]);
                            }
                        });
                        // perform all of the insert/update/delete operations in a single transaction
                        return [4 /*yield*/, this.db.batchSave(saveStatements, deleteStatements)];
                    case 2:
                        // perform all of the insert/update/delete operations in a single transaction
                        _b.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return CommonSQLiteAdapter;
}());
export { CommonSQLiteAdapter };
//# sourceMappingURL=CommonSQLiteAdapter.js.map