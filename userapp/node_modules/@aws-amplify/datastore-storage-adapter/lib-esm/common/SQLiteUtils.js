import { __read, __spread, __values } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { isGraphQLScalarType, QueryOne, isPredicateObj, isPredicateGroup, isModelFieldType, isTargetNameAssociation, isModelAttributeAuth, utils, } from '@aws-amplify/datastore';
var USER = utils.USER, isNonModelConstructor = utils.isNonModelConstructor, isModelConstructor = utils.isModelConstructor;
var keysFromModel = function (model) {
    return Object.keys(model)
        .map(function (k) { return "\"" + k + "\""; })
        .join(', ');
};
var valuesFromModel = function (model) {
    var values = Object.values(model).map(prepareValueForDML);
    var paramaterized = values.map(function () { return '?'; }).join(', ');
    return [paramaterized, values];
};
var updateSet = function (model) {
    var values = [];
    var paramaterized = Object.entries(model)
        .filter(function (_a) {
        var _b = __read(_a, 1), k = _b[0];
        return k !== 'id';
    })
        .map(function (_a) {
        var _b = __read(_a, 2), k = _b[0], v = _b[1];
        values.push(prepareValueForDML(v));
        return "\"" + k + "\"=?";
    })
        .join(', ');
    return [paramaterized, values];
};
function prepareValueForDML(value) {
    var scalarTypes = ['string', 'number', 'boolean'];
    var isScalarType = value === null || value === undefined || scalarTypes.includes(typeof value);
    if (isScalarType) {
        return value;
    }
    var isObjectType = typeof value === 'object' &&
        (Object.getPrototypeOf(value).constructor === Object ||
            isNonModelConstructor(Object.getPrototypeOf(value).constructor) ||
            isModelConstructor(Object.getPrototypeOf(value).constructor));
    if (Array.isArray(value) || isObjectType) {
        return JSON.stringify(value);
    }
    return "" + value;
}
export function getSQLiteType(scalar) {
    switch (scalar) {
        case 'Boolean':
        case 'Int':
        case 'AWSTimestamp':
            return 'INTEGER';
        case 'ID':
        case 'String':
        case 'AWSDate':
        case 'AWSTime':
        case 'AWSDateTime':
        case 'AWSEmail':
        case 'AWSJSON':
        case 'AWSURL':
        case 'AWSPhone':
        case 'AWSIPAddress':
            return 'TEXT';
        case 'Float':
            return 'REAL';
        default:
            var _ = scalar;
            throw new Error("unknown type " + scalar);
    }
}
export function generateSchemaStatements(schema) {
    return Object.keys(schema.namespaces).flatMap(function (namespaceName) {
        var namespace = schema.namespaces[namespaceName];
        var isUserModel = namespaceName === USER;
        return Object.values(namespace.models).map(function (model) {
            return modelCreateTableStatement(model, isUserModel);
        });
    });
}
export var implicitAuthFieldsForModel = function (model) {
    if (!model.attributes || !model.attributes.length) {
        return [];
    }
    var authRules = model.attributes.find(isModelAttributeAuth);
    if (!authRules) {
        return [];
    }
    var authFieldsForModel = authRules.properties.rules
        .filter(function (rule) { return rule.ownerField || rule.groupsField; })
        .map(function (rule) { return rule.ownerField || rule.groupsField; });
    return authFieldsForModel.filter(function (authField) {
        var authFieldExplicitlyDefined = Object.values(model.fields).find(function (f) { return f.name === authField; });
        return !authFieldExplicitlyDefined;
    });
};
export function modelCreateTableStatement(model, userModel) {
    if (userModel === void 0) { userModel = false; }
    // implicitly defined auth fields, e.g., `owner`, `groupsField`, etc.
    var implicitAuthFields = implicitAuthFieldsForModel(model);
    var fields = Object.values(model.fields).reduce(function (acc, field) {
        if (isGraphQLScalarType(field.type)) {
            if (field.name === 'id') {
                return __spread(acc, ['"id" PRIMARY KEY NOT NULL']);
            }
            var columnParam_1 = "\"" + field.name + "\" " + getSQLiteType(field.type);
            if (field.isRequired) {
                columnParam_1 += ' NOT NULL';
            }
            return __spread(acc, ["" + columnParam_1]);
        }
        if (isModelFieldType(field.type)) {
            var columnParam_2 = "\"" + field.name + "\" TEXT";
            // add targetName as well as field name for BELONGS_TO relations
            if (isTargetNameAssociation(field.association)) {
                // check if this field has been explicitly defined in the model
                var fkDefinedInModel = Object.values(model.fields).find(function (f) { var _a; return f.name === ((_a = field === null || field === void 0 ? void 0 : field.association) === null || _a === void 0 ? void 0 : _a.targetName); });
                // if the FK is not explicitly defined in the model, we have to add it here
                if (!fkDefinedInModel) {
                    var required = field.isRequired ? ' NOT NULL' : '';
                    columnParam_2 += ", \"" + field.association.targetName + "\" TEXT" + required;
                }
            }
            // ignore isRequired param for model fields, since they will not contain
            // the related data locally
            return __spread(acc, ["" + columnParam_2]);
        }
        // default to TEXT
        var columnParam = "\"" + field.name + "\" TEXT";
        if (field.isRequired) {
            columnParam += ' NOT NULL';
        }
        return __spread(acc, ["" + columnParam]);
    }, []);
    implicitAuthFields.forEach(function (authField) {
        fields.push(authField + " TEXT");
    });
    if (userModel) {
        fields = __spread(fields, [
            "\"_version\" INTEGER",
            "\"_lastChangedAt\" INTEGER",
            "\"_deleted\" INTEGER",
        ]);
    }
    var createTableStatement = "CREATE TABLE IF NOT EXISTS \"" + model.name + "\" (" + fields.join(', ') + ");";
    return createTableStatement;
}
export function modelInsertStatement(model, tableName) {
    var keys = keysFromModel(model);
    var _a = __read(valuesFromModel(model), 2), paramaterized = _a[0], values = _a[1];
    var insertStatement = "INSERT INTO \"" + tableName + "\" (" + keys + ") VALUES (" + paramaterized + ")";
    return [insertStatement, values];
}
export function modelUpdateStatement(model, tableName) {
    var _a = __read(updateSet(model), 2), paramaterized = _a[0], values = _a[1];
    var updateStatement = "UPDATE \"" + tableName + "\" SET " + paramaterized + " WHERE id=?";
    return [updateStatement, __spread(values, [model.id])];
}
export function queryByIdStatement(id, tableName) {
    return ["SELECT * FROM \"" + tableName + "\" WHERE \"id\" = ?", [id]];
}
/*
    Predicates supported by DataStore:

    Strings: eq | ne | le | lt | ge | gt | contains | notContains | beginsWith | between
    Numbers: eq | ne | le | lt | ge | gt | between
    Lists: contains | notContains
*/
var comparisonOperatorMap = {
    eq: '=',
    ne: '!=',
    le: '<=',
    lt: '<',
    ge: '>=',
    gt: '>',
};
var logicalOperatorMap = {
    beginsWith: '= 1',
    contains: '> 0',
    notContains: '= 0',
    between: 'BETWEEN',
};
/**
 * If the given (operator, operand) indicate the need for a special `NULL` comparison,
 * that `WHERE` clause condition will be returned. If not special `NULL` handling is
 * needed, `null` will be returned, and the caller should construct the `WHERE`
 * clause component using the normal operator map(s) and parameterization.
 *
 * @param operator "beginsWith" | "contains" | "notContains" | "between"
 * | "eq" | "ne" | "le" | "lt" | "ge" | "gt"
 * @param operand any
 * @returns (string | null) The `WHERE` clause component or `null` if N/A.
 */
function buildSpecialNullComparison(field, operator, operand) {
    if (operand === null || operand === undefined) {
        if (operator === 'eq') {
            return "\"" + field + "\" IS NULL";
        }
        else if (operator === 'ne') {
            return "\"" + field + "\" IS NOT NULL";
        }
    }
    // no special null handling required
    return null;
}
export var whereConditionFromPredicateObject = function (_a) {
    var field = _a.field, operator = _a.operator, operand = _a.operand;
    var specialNullClause = buildSpecialNullComparison(field, operator, operand);
    if (specialNullClause) {
        return [specialNullClause, []];
    }
    var comparisonOperator = comparisonOperatorMap[operator];
    if (comparisonOperator) {
        return ["\"" + field + "\" " + comparisonOperator + " ?", [operand]];
    }
    var logicalOperatorKey = operator;
    var logicalOperator = logicalOperatorMap[logicalOperatorKey];
    var statement;
    if (logicalOperator) {
        var rightExp = [];
        switch (logicalOperatorKey) {
            case 'between':
                rightExp = operand; // operand is a 2-tuple
                statement = [
                    "\"" + field + "\" " + logicalOperator + " " + rightExp
                        .map(function (_) { return '?'; })
                        .join(' AND '),
                    rightExp,
                ];
                break;
            case 'beginsWith':
            case 'contains':
            case 'notContains':
                statement = ["instr(\"" + field + "\", ?) " + logicalOperator, [operand]];
                break;
            default:
                var _ = logicalOperatorKey;
                // Incorrect WHERE clause can result in data loss
                throw new Error('Cannot map predicate to a valid WHERE clause');
        }
        return statement;
    }
};
export function whereClauseFromPredicate(predicate) {
    var result = [];
    var params = [];
    recurse(predicate, result, params);
    var whereClause = "WHERE " + result.join(' ');
    return [whereClause, params];
    function recurse(predicate, result, params) {
        var e_1, _a;
        if (result === void 0) { result = []; }
        if (params === void 0) { params = []; }
        if (isPredicateGroup(predicate)) {
            var groupType = predicate.type, groupPredicates = predicate.predicates;
            var filterType = '';
            var isNegation = false;
            switch (groupType) {
                case 'not':
                    isNegation = true;
                    break;
                case 'and':
                    filterType = 'AND';
                    break;
                case 'or':
                    filterType = 'OR';
                    break;
                default:
                    var _ = groupType;
                    throw new Error("Invalid " + groupType);
            }
            var groupResult = [];
            try {
                for (var groupPredicates_1 = __values(groupPredicates), groupPredicates_1_1 = groupPredicates_1.next(); !groupPredicates_1_1.done; groupPredicates_1_1 = groupPredicates_1.next()) {
                    var p = groupPredicates_1_1.value;
                    recurse(p, groupResult, params);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (groupPredicates_1_1 && !groupPredicates_1_1.done && (_a = groupPredicates_1.return)) _a.call(groupPredicates_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            result.push((isNegation ? 'NOT' : '') + "(" + groupResult.join(" " + filterType + " ") + ")");
        }
        else if (isPredicateObj(predicate)) {
            var _b = __read(whereConditionFromPredicateObject(predicate), 2), condition = _b[0], conditionParams = _b[1];
            result.push(condition);
            params.push.apply(params, __spread(conditionParams));
        }
    }
}
var sortDirectionMap = {
    ASCENDING: 'ASC',
    DESCENDING: 'DESC',
};
export function orderByClauseFromSort(sortPredicate) {
    if (sortPredicate === void 0) { sortPredicate = []; }
    var orderByParts = sortPredicate.map(function (_a) {
        var field = _a.field, sortDirection = _a.sortDirection;
        return "\"" + field + "\" " + sortDirectionMap[sortDirection];
    });
    // We always sort by _rowid_ last
    orderByParts.push("_rowid_ " + sortDirectionMap.ASCENDING);
    return "ORDER BY " + orderByParts.join(', ');
}
export function limitClauseFromPagination(limit, page) {
    if (page === void 0) { page = 0; }
    var params = [limit];
    var clause = 'LIMIT ?';
    if (page) {
        var offset = limit * page;
        params.push(offset);
        clause += ' OFFSET ?';
    }
    return [clause, params];
}
export function queryAllStatement(tableName, predicate, sort, limit, page) {
    var statement = "SELECT * FROM \"" + tableName + "\"";
    var params = [];
    if (predicate && predicate.predicates.length) {
        var _a = __read(whereClauseFromPredicate(predicate), 2), whereClause = _a[0], whereParams = _a[1];
        statement += " " + whereClause;
        params.push.apply(params, __spread(whereParams));
    }
    var orderByClause = orderByClauseFromSort(sort);
    statement += " " + orderByClause;
    if (limit) {
        var _b = __read(limitClauseFromPagination(limit, page), 2), limitClause = _b[0], limitParams = _b[1];
        statement += " " + limitClause;
        params.push.apply(params, __spread(limitParams));
    }
    return [statement, params];
}
export function queryOneStatement(firstOrLast, tableName) {
    if (firstOrLast === QueryOne.FIRST) {
        // ORDER BY rowid will no longer work as expected if a customer has
        // a field by that name in their schema. We may want to enforce it
        // as a reserved keyword in Codegen
        return ["SELECT * FROM " + tableName + " ORDER BY _rowid_ LIMIT 1", []];
    }
    else {
        return ["SELECT * FROM " + tableName + " ORDER BY _rowid_ DESC LIMIT 1", []];
    }
}
export function deleteByIdStatement(id, tableName) {
    var deleteStatement = "DELETE FROM \"" + tableName + "\" WHERE \"id\"=?";
    return [deleteStatement, [id]];
}
export function deleteByPredicateStatement(tableName, predicate) {
    var statement = "DELETE FROM \"" + tableName + "\"";
    var params = [];
    if (predicate && predicate.predicates.length) {
        var _a = __read(whereClauseFromPredicate(predicate), 2), whereClause = _a[0], whereParams = _a[1];
        statement += " " + whereClause;
        params.push.apply(params, __spread(whereParams));
    }
    return [statement, params];
}
//# sourceMappingURL=SQLiteUtils.js.map